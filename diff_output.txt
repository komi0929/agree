diff --git a/components/split-view/contract-viewer.tsx b/components/split-view/contract-viewer.tsx
index 5050665..a82eb00 100644
--- a/components/split-view/contract-viewer.tsx
+++ b/components/split-view/contract-viewer.tsx
@@ -1,6 +1,6 @@
 "use client";
 
-import { useEffect, useRef, useCallback } from "react";
+import { useEffect, useRef, useCallback, useMemo } from "react";
 import { EnhancedAnalysisResult } from "@/lib/types/analysis";
 import { FileText } from "lucide-react";
 
@@ -11,130 +11,168 @@ interface ContractViewerProps {
     onHighlightClick?: (index: number) => void;
 }
 
+interface Match {
+    start: number;
+    end: number;
+    riskIndex: number;
+}
+
 export function ContractViewer({ text, risks, highlightedRiskIndex, onHighlightClick }: ContractViewerProps) {
     const containerRef = useRef<HTMLDivElement>(null);
-    const highlightRefs = useRef<Map<number, HTMLDivElement>>(new Map());
-
-    // Create highlighted text with matching regions
-    const createHighlightedContent = useCallback(() => {
-        // Build a list of text regions with their risk associations
-        const regions: Array<{
-            text: string;
-            riskIndices: number[];
-            isHighlight: boolean;
-        }> = [];
+    const highlightRef = useRef<HTMLSpanElement>(null);
 
-        // Find all risk matches in the text
-        const matches: Array<{ start: number; end: number; riskIndex: number }> = [];
-
-        // Normalize function to handle whitespace differences
+    // Find all matches for all risks
+    const matches = useMemo(() => {
+        const foundMatches: Match[] = [];
         const normalizeText = (str: string) => str.replace(/\s+/g, ' ').trim();
         const normalizedContractText = normalizeText(text);
 
         risks.forEach((risk, index) => {
-            if (!risk.original_text || risk.original_text.length < 5) return;
-
-            const normalizedOriginal = normalizeText(risk.original_text);
+            if (!risk?.original_text || risk.original_text.length < 5) return;
+            // Skip low risk (missing clauses) as they don't exist in text
+            if (risk.risk_level === "low") return;
 
-            // Strategy 1: Try direct match in original text
+            // Strategy 1: Direct match
             let pos = text.indexOf(risk.original_text);
             if (pos !== -1) {
-                matches.push({
-                    start: pos,
-                    end: pos + risk.original_text.length,
-                    riskIndex: index,
-                });
+                // Limit highlight length to avoid "meaningless" huge highlights
+                // If it's too long, it's often the whole article which isn't helpful
+                const maxLength = Math.min(risk.original_text.length, 180);
+                foundMatches.push({ start: pos, end: pos + maxLength, riskIndex: index });
                 return;
             }
 
-            // Strategy 2: Try normalized match (handles whitespace differences)
+            // Strategy 2: Normalized match (handles whitespace differences)
+            const normalizedOriginal = normalizeText(risk.original_text);
+            if (normalizedOriginal.length < 5) return;
+
             const normalizedPos = normalizedContractText.indexOf(normalizedOriginal);
             if (normalizedPos !== -1) {
-                // Map back to original text position
                 let originalPos = 0;
                 let normalizedIdx = 0;
+
+                // Map back normalized position to original text position
                 while (normalizedIdx < normalizedPos && originalPos < text.length) {
-                    if (!/\s/.test(text[originalPos]) || normalizedContractText[normalizedIdx] === text[originalPos]) {
+                    const char = text[originalPos];
+                    if (/\s/.test(char)) {
+                        originalPos++;
+                        continue;
+                    }
+                    if (normalizedContractText[normalizedIdx] === char) {
                         normalizedIdx++;
                     }
                     originalPos++;
                 }
-                matches.push({
+
+                const maxLength = Math.min(risk.original_text.length, 180);
+                foundMatches.push({
                     start: originalPos,
-                    end: Math.min(originalPos + risk.original_text.length, text.length),
-                    riskIndex: index,
+                    end: Math.min(originalPos + maxLength, text.length),
+                    riskIndex: index
                 });
-                return;
             }
-
-            // No match found - don't highlight to avoid incorrect positions
-            // (Previously had Strategy 3 and 4 which caused wrong highlights)
         });
 
-        // Sort matches by start position
-        matches.sort((a, b) => a.start - b.start);
-
-        // Build regions
-        let lastEnd = 0;
-        matches.forEach((match) => {
-            // Add non-highlighted region before this match
-            if (match.start > lastEnd) {
-                regions.push({
-                    text: text.slice(lastEnd, match.start),
-                    riskIndices: [],
-                    isHighlight: false,
-                });
-            }
-
-            // Add highlighted region
-            regions.push({
-                text: text.slice(match.start, match.end),
-                riskIndices: [match.riskIndex],
-                isHighlight: true,
-            });
-
-            lastEnd = match.end;
-        });
+        // Sort matches by start position and remove overlaps
+        return foundMatches
+            .sort((a, b) => a.start - b.start)
+            .reduce((acc, current) => {
+                if (acc.length === 0) return [current];
+                const last = acc[acc.length - 1];
+                // If they overlap, keep the one that matches the currently selected risk, 
+                // or just keep the first one
+                if (current.start >= last.end) {
+                    acc.push(current);
+                } else if (current.riskIndex === highlightedRiskIndex) {
+                    // Replace previous with this one if this is the active selection
+                    acc[acc.length - 1] = current;
+                }
+                return acc;
+            }, [] as Match[]);
+    }, [text, risks, highlightedRiskIndex]);
 
-        // Add any remaining text
-        if (lastEnd < text.length) {
-            regions.push({
-                text: text.slice(lastEnd),
-                riskIndices: [],
-                isHighlight: false,
-            });
+    // Scroll to highlighted text when selection changes
+    useEffect(() => {
+        if (highlightedRiskIndex !== null && highlightRef.current) {
+            highlightRef.current.scrollIntoView({ behavior: "smooth", block: "center" });
         }
+    }, [highlightedRiskIndex]);
 
-        return regions;
-    }, [text, risks]);
+    // Color styling for highlights
+    const getHighlightStyles = (riskIndex: number) => {
+        const risk = risks[riskIndex];
+        const isActive = highlightedRiskIndex === riskIndex;
 
-    const regions = createHighlightedContent();
+        const base = "inline cursor-pointer transition-all duration-200 rounded px-1 py-0.5 border-b-2 font-medium";
 
-    // Scroll to highlighted risk
-    useEffect(() => {
-        if (highlightedRiskIndex !== null) {
-            const element = highlightRefs.current.get(highlightedRiskIndex);
-            if (element) {
-                element.scrollIntoView({ behavior: "smooth", block: "center" });
+        if (isActive) {
+            const activeBase = `${base} font-bold ring-4 ring-offset-1 shadow-lg z-10 scale-[1.03] animate-in fade-in zoom-in-95 duration-300`;
+            switch (risk?.risk_level) {
+                case "critical": return `${activeBase} bg-purple-200 border-purple-500 text-purple-900 ring-purple-300`;
+                case "high": return `${activeBase} bg-red-200 border-red-500 text-red-900 ring-red-300`;
+                case "medium": return `${activeBase} bg-yellow-200 border-yellow-500 text-yellow-900 ring-yellow-300`;
+                default: return `${activeBase} bg-green-200 border-green-500 text-green-900 ring-green-300`;
+            }
+        } else {
+            const inactiveBase = `${base} opacity-70 hover:opacity-100 hover:scale-[1.01]`;
+            switch (risk?.risk_level) {
+                case "critical": return `${inactiveBase} bg-purple-100/50 border-purple-200 text-purple-800`;
+                case "high": return `${inactiveBase} bg-red-100/50 border-red-200 text-red-800`;
+                case "medium": return `${inactiveBase} bg-yellow-100/50 border-yellow-200 text-yellow-800`;
+                default: return `${inactiveBase} bg-green-100/50 border-green-200 text-green-800`;
             }
         }
-    }, [highlightedRiskIndex]);
+    };
 
-    // Get risk level color
-    const getRiskColor = (riskIndex: number) => {
-        const risk = risks[riskIndex];
-        if (!risk) return { bg: "bg-slate-100", border: "border-slate-300", text: "text-slate-600" };
-
-        switch (risk.risk_level) {
-            case "critical":
-                return { bg: "bg-purple-50", border: "border-purple-400", text: "text-purple-700" };
-            case "high":
-                return { bg: "bg-red-50", border: "border-red-400", text: "text-red-700" };
-            case "medium":
-                return { bg: "bg-yellow-50", border: "border-yellow-400", text: "text-yellow-700" };
-            default:
-                return { bg: "bg-green-50", border: "border-green-400", text: "text-green-700" };
+    const renderContent = () => {
+        if (matches.length === 0) {
+            return text.split(/(\n)/).map((segment, i) => (
+                <span key={i} className="whitespace-pre-wrap text-slate-600">
+                    {segment}
+                </span>
+            ));
         }
+
+        const elements: React.ReactNode[] = [];
+        let lastIdx = 0;
+
+        matches.forEach((match, i) => {
+            // Text before match
+            if (match.start > lastIdx) {
+                const beforeText = text.slice(lastIdx, match.start);
+                elements.push(
+                    <span key={`text-before-${i}`} className="whitespace-pre-wrap text-slate-600">
+                        {beforeText}
+                    </span>
+                );
+            }
+
+            // The highlight
+            const isActive = highlightedRiskIndex === match.riskIndex;
+            elements.push(
+                <span
+                    key={`match-${i}`}
+                    ref={isActive ? highlightRef : undefined}
+                    onClick={() => onHighlightClick?.(match.riskIndex)}
+                    className={getHighlightStyles(match.riskIndex)}
+                >
+                    {text.slice(match.start, match.end)}
+                </span>
+            );
+
+            lastIdx = match.end;
+        });
+
+        // Remaining text
+        if (lastIdx < text.length) {
+            elements.push(
+                <span key="text-remaining" className="whitespace-pre-wrap text-slate-600">
+                    {text.slice(lastIdx)}
+                </span>
+            );
+        }
+
+        return elements;
     };
 
     return (
@@ -145,67 +183,23 @@ export function ContractViewer({ text, risks, highlightedRiskIndex, onHighlightC
                     <FileText className="w-4 h-4 text-slate-500" />
                     <span className="text-sm font-medium text-slate-700">å¥‘ç´„æ›¸</span>
                 </div>
-                <span className="text-xs text-slate-400">
-                    è‰²ä»˜ã = è¦ç¢ºèª
-                </span>
+                <div className="flex items-center gap-2">
+                    <span className="text-[10px] text-slate-400 bg-slate-100 px-2 py-0.5 rounded-full">
+                        ãƒã‚¤ãƒ©ã‚¤ãƒˆã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦ãƒªã‚¹ã‚¯ã‚’ç¢ºèª
+                    </span>
+                </div>
             </div>
 
-            {/* Content */}
-            <div
-                ref={containerRef}
-                className="flex-1 overflow-auto p-8 bg-white"
-            >
-                <div className="max-w-none prose prose-sm prose-slate leading-loose">
-                    {regions.map((region, idx) => {
-                        // èª­ã¿ã‚„ã™ã•ã®ãŸã‚ã«å¥ç‚¹ã®å¾Œã«æ”¹è¡Œã‚’å…¥ã‚Œã‚‹å‡¦ç†ï¼ˆãƒã‚¤ãƒ©ã‚¤ãƒˆã•ã‚Œã¦ã„ãªã„éƒ¨åˆ†ã®ã¿ï¼‰
-                        // ãŸã ã—ã€å…ƒã€…æ”¹è¡ŒãŒã‚ã‚‹å ´åˆã¯ãã®ã¾ã¾ã«ã™ã‚‹
-                        const displayContent = !region.isHighlight
-                            ? region.text.split(/(?<=ã€‚)/).map((segment, i, arr) => (
-                                <span key={i}>
-                                    {segment}
-                                    {i < arr.length - 1 && !segment.endsWith('\n') && <br className="mb-2 block content-['']" />}
-                                </span>
-                            ))
-                            : region.text;
-
-                        if (!region.isHighlight) {
-                            return (
-                                <span key={idx} className="whitespace-pre-wrap text-slate-600">
-                                    {displayContent}
-                                </span>
-                            );
-                        }
-
-                        // Highlighted region
-                        const riskIndex = region.riskIndices[0];
-                        const colors = getRiskColor(riskIndex);
-                        const isActive = highlightedRiskIndex === riskIndex;
-
-                        return (
-                            <span
-                                key={idx}
-                                ref={(el) => {
-                                    if (el) highlightRefs.current.set(riskIndex, el as any);
-                                }}
-                                className={`
-                                    relative inline cursor-pointer transition-all duration-300 rounded-sm
-                                    ${colors.bg} ${isActive ? `ring-4 ${colors.border} ring-offset-2 z-10 font-bold shadow-sm` : "hover:brightness-95"}
-                                    border-b-2 ${colors.border} px-1 py-0.5 mx-0.5
-                                `}
-                                onClick={() => onHighlightClick?.(riskIndex)}
-                            >
-                                {/* Risk number badge */}
-                                <span className={`
-                                    absolute -left-3 -top-3 w-5 h-5 rounded-full flex items-center justify-center
-                                    text-[10px] font-bold ${colors.bg} ${colors.text} ${colors.border} border shadow-sm
-                                    transition-transform duration-300 ${isActive ? 'scale-125' : 'scale-100'}
-                                `}>
-                                    {riskIndex + 1}
-                                </span>
-                                {region.text}
-                            </span>
-                        );
-                    })}
+            {/* Content Container */}
+            <div className="flex-1 overflow-auto bg-white">
+                <div
+                    ref={containerRef}
+                    className="max-w-3xl mx-auto p-12 lg:p-16 min-h-full shadow-inner bg-white font-serif leading-relaxed"
+                    style={{ fontSize: "15px" }}
+                >
+                    <div className="space-y-1">
+                        {renderContent()}
+                    </div>
                 </div>
             </div>
         </div>
diff --git a/components/split-view/risk-panel.tsx b/components/split-view/risk-panel.tsx
index 995c26f..e438b96 100644
--- a/components/split-view/risk-panel.tsx
+++ b/components/split-view/risk-panel.tsx
@@ -51,14 +51,20 @@ export function RiskPanel({
     }, []);
 
     // Scroll to highlighted card when highlightedRiskIndex changes
-    // Only scroll programmatically when it's triggered by clicking on contract highlights
     useEffect(() => {
         if (highlightedRiskIndex !== null && highlightedRiskIndex !== -1) {
+            // Auto-expand the highlighted card
+            setExpandedCards(prev => {
+                if (prev.has(highlightedRiskIndex)) return prev;
+                const next = new Set(prev);
+                next.add(highlightedRiskIndex);
+                return next;
+            });
+
             // Don't scroll if user is manually scrolling or if we just scrolled to this index
             if (isUserScrolling.current) {
                 return;
             }
-            // Only scroll if this is a new index (not from hover)
             if (lastProgrammaticScrollIndex.current === highlightedRiskIndex) {
                 return;
             }
@@ -345,16 +351,18 @@ export function RiskPanel({
                                         </div>
                                     )}
 
-                                    {/* Contract Link */}
-                                    <button
-                                        className="flex items-center gap-1 text-xs text-blue-600 hover:text-blue-800 transition-colors"
-                                        onClick={(e) => {
-                                            e.stopPropagation();
-                                            onScrollToContract(index);
-                                        }}
-                                    >
-                                        ğŸ“ å¥‘ç´„æ›¸ã§ç¢ºèª
-                                    </button>
+                                    {/* Contract Link - hide for low risk (missing clauses don't exist in text) */}
+                                    {!isLowRisk && (
+                                        <button
+                                            className="flex items-center gap-1 text-xs text-blue-600 hover:text-blue-800 transition-colors"
+                                            onClick={(e) => {
+                                                e.stopPropagation();
+                                                onScrollToContract(index);
+                                            }}
+                                        >
+                                            ğŸ“ å¥‘ç´„æ›¸ã§ç¢ºèª
+                                        </button>
+                                    )}
                                 </div>
                             )}
                         </div>
diff --git a/lib/ai-service.ts b/lib/ai-service.ts
index c7c46ef..bb82fa4 100644
--- a/lib/ai-service.ts
+++ b/lib/ai-service.ts
@@ -192,7 +192,7 @@ ${lawContext}
     {
       "clause_tag": "CLAUSE_PAYMENT | CLAUSE_IP | CLAUSE_LIABILITY | CLAUSE_SCOPE | CLAUSE_TERMINATION | CLAUSE_NON_COMPETE | CLAUSE_OTHER",
       "section_title": "æ¡é …ã®ã‚¿ã‚¤ãƒˆãƒ«ï¼ˆä¾‹ï¼šç¬¬4æ¡ æ”¯æ‰•æ¡ä»¶ï¼‰",
-      "original_text": "ã€å¿…é ˆã€‘å•é¡Œã®ã‚ã‚‹å¥‘ç´„æ›¸ã®åŸæ–‡ã‚’ãã®ã¾ã¾æŠœç²‹ï¼ˆãƒã‚¤ãƒ©ã‚¤ãƒˆç”¨ã€20-100æ–‡å­—ç¨‹åº¦ï¼‰",
+      "original_text": "ã€æœ€é‡è¦ã€‘å•é¡ŒãŒã‚ã‚‹ç®‡æ‰€ã®åŸæ–‡ã‚’ã€å®Œå…¨ã«ä¸€è‡´ã™ã‚‹å½¢å¼ã€ã§20ã€œ80æ–‡å­—ç¨‹åº¦ã§æŠœç²‹ã€‚ãƒã‚¤ãƒ©ã‚¤ãƒˆè¡¨ç¤ºã«ä½¿ç”¨ã™ã‚‹ãŸã‚ã€æ”¹è¡Œã‚„ç©ºç™½ã‚‚å«ã‚æ­£ç¢ºã«ã€‚é•·ã™ãã‚‹ã¨ãƒã‚¤ãƒ©ã‚¤ãƒˆãŒåŸ‹ã‚‚ã‚Œã‚‹ãŸã‚ã€æ ¸å¿ƒéƒ¨åˆ†ã®ã¿ã‚’æŠ½å‡ºã—ã¦ãã ã•ã„ã€‚",
       "risk_level": "critical | high | medium | low",
       "violated_laws": ["è©²å½“ã™ã‚‹æ³•å¾‹ã®ã‚³ãƒ¼ãƒ‰"],
       "explanation": "ãªãœã“ã®æ¡é …ã«ãƒªã‚¹ã‚¯ãŒã‚ã‚‹ã®ã‹ã®èª¬æ˜",
@@ -211,10 +211,10 @@ ${lawContext}
   "missing_clauses": ["æ¬ è½ã—ã¦ã„ã‚‹é‡è¦æ¡é …ã®ãƒªã‚¹ãƒˆ"]
 }
 
-ã€original_textã«ã¤ã„ã¦ã€‘
-- å¿…ãšå¥‘ç´„æ›¸ã‹ã‚‰å•é¡Œç®‡æ‰€ã®æ–‡ç« ã‚’ã‚³ãƒ”ãƒ¼ã—ã¦ãã ã•ã„
-- ã“ã‚ŒãŒãªã„ã¨ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒå•é¡Œç®‡æ‰€ã‚’ç‰¹å®šã§ãã¾ã›ã‚“
-- ä¾‹ï¼šã€Œæ¤œåå®Œäº†ã®ç¿Œæœˆæœ«ã¾ã§ã«ã€ç”²ã®æŒ‡å®šã™ã‚‹æ–¹æ³•ã«ã‚ˆã‚Šæ”¯æ‰•ã†ã‚‚ã®ã¨ã™ã‚‹ã€`;
+ã€original_textã«é–¢ã™ã‚‹æ³¨æ„äº‹é …ã€‘
+- å¥‘ç´„æ›¸æœ¬æ–‡ã‹ã‚‰ã€å•é¡Œã®ã‚ã‚‹ç®‡æ‰€ã‚’ã€ä¸€è¨€ä¸€å¥é•ã‚ãšã«ã€ã‚³ãƒ”ãƒ¼ï¼†ãƒšãƒ¼ã‚¹ãƒˆã—ã¦ãã ã•ã„ã€‚
+- ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯ã“ã®åŸæ–‡ã‚’å…ƒã«å¥‘ç´„æ›¸å†…ã®å ´æ‰€ã‚’ç‰¹å®šã—ã¾ã™ã€‚ä¸æ­£ç¢ºã ã¨ãƒã‚¤ãƒ©ã‚¤ãƒˆãŒè¡¨ç¤ºã•ã‚Œã¾ã›ã‚“ã€‚
+- æ¡é …å…¨ä½“ã‚’æŠœãå‡ºã™ã®ã§ã¯ãªãã€å•é¡Œã®æ ¸å¿ƒã¨ãªã£ã¦ã„ã‚‹1ã€œ2æ–‡ç¨‹åº¦ã«çµã£ã¦ãã ã•ã„ã€‚`;
 }
 
 // ============================================
